import re
import os

def detect_vulnerabilities(input_file):
    with open(input_file, 'r') as f:
        code = f.read()

    vulnerabilities = {
        "integer_overflow": [],
        "buffer_overflow": [],
        "division_by_zero": []
    }

    # Detect integer overflow (addition, subtraction, multiplication, division)
    int_overflow_pattern = re.compile(r"\b(int|unsigned int)\s+\w+\s*=\s*(INT_MAX|INT_MIN|UINT_MAX)\s*[\+\-\*/]\s*\d+;")
    int_overflow_pattern_more = re.compile(r"\b(int|unsigned int)\s+\w+\s*=\s*\w+\s*[\+\-\*/]\s*(INT_MAX|INT_MIN|UINT_MAX);")
    vulnerabilities["integer_overflow"].extend(int_overflow_pattern.findall(code))
    vulnerabilities["integer_overflow"].extend(int_overflow_pattern_more.findall(code))

    # Detect buffer overflow (array index out of bounds)
    buffer_overflow_pattern = re.compile(r"\w+\[\d+\]\s*=\s*.*;")  # Array access pattern
    buffer_overflow_pattern_more = re.compile(r"\w+\[\w+\]\s*=\s*.*;")  # Variable index pattern
    vulnerabilities["buffer_overflow"].extend(buffer_overflow_pattern.findall(code))
    vulnerabilities["buffer_overflow"].extend(buffer_overflow_pattern_more.findall(code))

    # Detect division by zero
    division_by_zero_pattern = re.compile(r"/\s*0")
    division_by_zero_pattern_var = re.compile(r"\b(\w+)\s*=\s*0\s*;\s*.*\b/\s*\1")  # Division by zero when variable is 0
    vulnerabilities["division_by_zero"].extend(division_by_zero_pattern.findall(code))
    vulnerabilities["division_by_zero"].extend(division_by_zero_pattern_var.findall(code))

    return vulnerabilities


def generate_test_cases(vulnerabilities, output_dir):
    os.makedirs(output_dir, exist_ok=True)

    # Integer overflow test case
    if vulnerabilities["integer_overflow"]:
        with open(os.path.join(output_dir, "integer_overflow_test.cpp"), 'w') as f:
            f.write("""
#include <iostream>
#include <climits>

int main() {
    // Integer Overflow Example
    int a = INT_MAX;
    int b = 1;
    int c = a + b; // Integer overflow
    std::cout << "Result: " << c << std::endl;
    return 0;
}
""")

    # Buffer overflow test case
    if vulnerabilities["buffer_overflow"]:
        with open(os.path.join(output_dir, "buffer_overflow_test.cpp"), 'w') as f:
            f.write("""
#include <iostream>

int main() {
    // Buffer overflow example
    char buffer[5];
    for (int i = 0; i <= 5; i++) { // Buffer overflow
        buffer[i] = 'A';
    }
    std::cout << "Buffer overflowed!" << std::endl;
    return 0;
}
""")

    # Division by zero test case
    if vulnerabilities["division_by_zero"]:
        with open(os.path.join(output_dir, "division_by_zero_test.cpp"), 'w') as f:
            f.write("""
#include <iostream>

int main() {
    int a = 10;
    int b = 0;
    int c = a / b; // Division by zero
    std::cout << "Result: " << c << std::endl;
    return 0;
}
""")


def main():
    # Get the input file from the user
    input_file = input("Enter the path to the C/C++ file you want to analyze: ").strip()

    # Check if the file exists
    if not os.path.isfile(input_file):
        print(f"Error: File '{input_file}' does not exist.")
        return

    output_dir = "test_cases"

    # Detect vulnerabilities in the input file
    vulnerabilities = detect_vulnerabilities(input_file)

    # Report and generate test cases
    if any(vulnerabilities.values()):
        print("Vulnerabilities detected:")
        for vuln_type, occurrences in vulnerabilities.items():
            print(f"{vuln_type}: {len(occurrences)} occurrence(s)")
        generate_test_cases(vulnerabilities, output_dir)
        print(f"Test cases generated in the '{output_dir}' directory.")
    else:
        print("No vulnerabilities detected.")

if __name__ == "__main__":
    main()
